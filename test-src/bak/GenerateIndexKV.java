package bak;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

public class GenerateIndexKV {

  Map<String, ArrayList<String>> rowkeyMap = new HashMap<String, ArrayList<String>>();
  ArrayList<KeyValue> results = new ArrayList<GenerateIndexKV.KeyValue>();

  static class KeyValue {
    public String key;
    public String value;
    public boolean isIndex;

    public static final String DELIMITER = "#";

    public KeyValue(String key, String value, boolean isIndex) {
      this.key = key;
      this.value = value;
      this.isIndex = isIndex;
    }

    @Override
    public String toString() {
      return key + ": " + value + ", " + (isIndex ? "indexed" : "not indexed");
    }

    public String toIndexKey() {
      return value + DELIMITER + key;
    }

    public static String getRowKeyFromFullIndexKey(String indexKey) {
      String temp[] = indexKey.split(DELIMITER);
      return temp[1];
    }

    public static String getRawValueFromFullIndexKey(String indexKey) {
      String temp[] = indexKey.split(DELIMITER);
      return temp[0];
    }
  }

  void fillKVList(List<KeyValue> kvList, String[] values) {
    kvList.add(new KeyValue(values[0], values[1], false));
    for (int i = 2; i < values.length; ++i) {
      kvList.add(new KeyValue(values[0], values[i], true));
    }
  }

  public void work() {
    String[] row1 = { "k1", "info-1", "A-1", "B-1" };
    String[] row2 = { "k2", "info-2", "A-2", "B-2" };
    List<KeyValue> kvList = new ArrayList<KeyValue>();
    fillKVList(kvList, row1);
    fillKVList(kvList, row2);
    printList(kvList);
    generateIndexedKVList(kvList);
    System.out.println("*********");
    printList(results);
  }

  private void generateIndexedKVList(List<KeyValue> kvList) {
    // this maps of rowkeys. the value is a list of all possible new keys generated by index
    Queue<KeyValue> queue = new LinkedList<KeyValue>();
    for (KeyValue kv : kvList) {
       if(!kv.isIndex){
         queue.add(kv);
       }else{
         processOne(kv);
       }
    }
    while(!queue.isEmpty()){
      processOne(queue.poll());
    }
  }

  private void processOne(KeyValue kv) {
    if (rowkeyMap.containsKey(kv.key)) { // already has the rowkey, first get the list
      ArrayList<String> listOfIndexedKeys = rowkeyMap.get(kv.key);
      for (String str : listOfIndexedKeys) {
        results.add(new KeyValue(str, kv.value, false));
        if (kv.isIndex) {
          results.add(new KeyValue(kv.toIndexKey(), KeyValue.getRawValueFromFullIndexKey(str),
              false));
        }
      }
      if (kv.isIndex) { // add new KeyValue back
        listOfIndexedKeys.add(kv.toIndexKey());
      }
    } else { // new added rowkey
      ArrayList<String> listOfIndexedKeys = new ArrayList<String>();
      listOfIndexedKeys.add(kv.toIndexKey());
      rowkeyMap.put(kv.key, listOfIndexedKeys);
    }
  }

  void printList(List<KeyValue> kvList) {
    for (KeyValue kv : kvList) {
      System.out.println(kv);
    }
  }

  public static void main(String[] args) {
    new GenerateIndexKV().work();
  }
}
