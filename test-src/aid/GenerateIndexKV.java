package aid;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import org.apache.hadoop.hbase.util.Bytes;

public class GenerateIndexKV {

  Map<byte[], ArrayList<byte[]>> rowkeyMap = new HashMap<byte[], ArrayList<byte[]>>();
  ArrayList<KeyValue> results = new ArrayList<GenerateIndexKV.KeyValue>();

  static class KeyValue {
    public byte[] key;
    public byte[] value;
    public boolean isIndex;

    public static final String DELIMITER_STR = "#";
    public static final byte[] DELIMITER = Bytes.toBytes(DELIMITER_STR);

    public KeyValue(byte[] key, byte[] value, boolean isIndex) {
      this.key = key;
      this.value = value;
      this.isIndex = isIndex;
    }

    @Override
    public String toString() {
      return Bytes.toString(key) + ": " + Bytes.toString(value) + ", " + (isIndex ? "indexed" : "not indexed");
    }

    public byte[] toIndexKey() {
      return Bytes.add(Bytes.add(value, DELIMITER), key);
    }

    public static String getRowKeyFromFullIndexKey(byte[] indexKey) {
      String temp[] = Bytes.toString(indexKey).split(DELIMITER_STR);
      return temp[1];
    }

    public static byte[] getRawValueFromFullIndexKey(byte[] indexKey) {
      String temp[] = Bytes.toString(indexKey).split(DELIMITER_STR);
      return Bytes.toBytes(temp[0]);
    }
  }

  void fillKVList(List<KeyValue> kvList, String[] values) {
    kvList.add(new KeyValue(Bytes.toBytes(values[0]), Bytes.toBytes(values[1]), false));
    for (int i = 2; i < values.length; ++i) {
      kvList.add(new KeyValue(Bytes.toBytes(values[0]), Bytes.toBytes(values[i]), true));
    }
  }

  public void work() {
    String[] row1 = { "k1", "info-1", "A-1", "B-1" };
    String[] row2 = { "k2", "info-2", "A-2", "B-2" };
    List<KeyValue> kvList = new ArrayList<KeyValue>();
    fillKVList(kvList, row1);
    fillKVList(kvList, row2);
    printList(kvList);
    generateIndexedKVList(kvList);
    System.out.println("*********");
    printList(results);
  }

  private void generateIndexedKVList(List<KeyValue> kvList) {
    // this maps of rowkeys. the value is a list of all possible new keys generated by index
    Queue<KeyValue> queue = new LinkedList<KeyValue>();
    for (KeyValue kv : kvList) {
      if (!kv.isIndex) {
        queue.add(kv);
      } else {
        processOne(kv);
      }
    }
    while (!queue.isEmpty()) {
      processOne(queue.poll());
    }
  }

  private void processOne(KeyValue kv) {
    if (rowkeyMap.containsKey(kv.key)) { // already has the rowkey, first get the list
      ArrayList<byte[]> listOfIndexedKeys = rowkeyMap.get(kv.key);
      for (byte[] indexedKey : listOfIndexedKeys) {
        results.add(new KeyValue(indexedKey, kv.value, false));
        if (kv.isIndex) {
          results.add(new KeyValue(kv.toIndexKey(), KeyValue
              .getRawValueFromFullIndexKey(indexedKey), false));
        }
      }
      if (kv.isIndex) { // add new KeyValue back
        listOfIndexedKeys.add(kv.toIndexKey());
      }
    } else { // new added rowkey
      ArrayList<byte[]> listOfIndexedKeys = new ArrayList<byte[]>();
      listOfIndexedKeys.add(kv.toIndexKey());
      rowkeyMap.put(kv.key, listOfIndexedKeys);
    }
  }

  void printList(List<KeyValue> kvList) {
    for (KeyValue kv : kvList) {
      System.out.println(kv);
    }
  }

  public static void main(String[] args) {
    new GenerateIndexKV().work();
  }
}
